import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as o,a,e as d}from"./app-880ed8c8.js";const r={};function p(m,e){const t=i("Mermaid");return l(),o("div",null,[e[0]||(e[0]=a('<h1 id="理解" tabindex="-1"><a class="header-anchor" href="#理解" aria-hidden="true">#</a> 理解</h1><h2 id="react-哲学" tabindex="-1"><a class="header-anchor" href="#react-哲学" aria-hidden="true">#</a> React 哲学</h2><blockquote><p>React 可以改变你对可见设计和应用构建的思考。当你使用 React 构建用户界面时，你首先会把它分解成一个个 组件，然后，你需要把这些组件连接在一起，使数据流经它们。</p></blockquote><p>从它的哲学：一个个组件，我们可以扩展出两个需要思考的性能问题：</p><ol><li>大量组件下，如何保证用户界面的流程构建</li><li>在依赖网络请求的情况下，如何加快组件的获取</li></ol><p>带着问题，我们去看React如何解决</p><h2 id="大量组件-cpu瓶颈" tabindex="-1"><a class="header-anchor" href="#大量组件-cpu瓶颈" aria-hidden="true">#</a> 大量组件（CPU瓶颈）</h2><p>这里的瓶颈要理解，是在持续渲染的过程中的瓶颈。初始渲染（首屏优化）需要从另一个方向去思考。</p><p>已知：页面渲染需要经过GUI线程，JS线程。两者是互斥的。如果js执行时间多于一帧的时间，给用户的感知就是页面卡顿了。</p><p>Fiber方案：在浏览器每一帧的时间中，预留一些时间给 JS 线程，React利用这部分时间更新组件（可以看到，在源码中，预留的初始时间是 5ms）。</p><blockquote><p>任何超过50ms的任务都被认为是&quot;长任务&quot;，可能会导致用户体验问题</p></blockquote><p>关键就是：可中断。</p><h3 id="react是如何知道每一帧里面还有多少空余时间呢" tabindex="-1"><a class="header-anchor" href="#react是如何知道每一帧里面还有多少空余时间呢" aria-hidden="true">#</a> React是如何知道每一帧里面还有多少空余时间呢？</h3><p>React的调度器确实需要知道在一帧中有多少时间可以使用，这是实现时间切片（Time Slicing）的关键。React是如何做到这一点的呢？让我们深入了解一下：</p><ol><li>帧的概念：<br> 在理想情况下，浏览器以60帧/秒的速度渲染内容，这意味着每帧大约有16.67毫秒（1000ms / 60 ≈ 16.67ms）。</li><li>requestIdleCallback：<br> React的灵感来自于浏览器的<code>requestIdleCallback</code> API，但由于兼容性和精确度问题，React实现了自己的版本。</li><li>React的定时机制：<br> React使用<code>requestAnimationFrame</code>来模拟<code>requestIdleCallback</code>，这允许它在每帧开始时进行调度。</li><li>时间估算：<br> React会估算每帧中可用的时间。它假设理想的帧时间是16.67ms，但会根据实际情况动态调整。</li><li>动态调整：<br> 如果React发现它的工作导致帧超时（丢帧），它会相应地减少下一帧中的工作量。</li></ol><p>让我们用一个图表来可视化一个帧的时间线：</p>',16)),d(t,{id:"mermaid-85",code:"eJzFWUtv20YQvudXsDECSIVIkHrZloEeWqSnAAECX3pckity4RWX2F1JdgQDPbRoe8rRSNFrkfTSQ9FHECDon7Hj+l90lg9JVLRLSkFdCpYlzuvbmdnZ4egZRoG0vuRogq1TMsGUJNgJ2TyhDIU2CVhiLR5Ya1cw5YLxkZUykkjMTypEyVEixoxPbMZJRJKRFeAq1+Xy04YVB3HO5naKuNywmCklkjBQtzRguU5vIACNTwLbx88J5i11qwOErnrz+ur9eNCuItwJoj+VEqzGSLSqaNujmM0wN6yhYxIes2Aq7BkRxKe4qSOWwAsvUCTxVy3bcwbp+doiV+gPJphPEAntkKAIAmzzw95izBJpj9GE0IvRDPGWbWd3IkyEtAWobZ9kNwR5jkdeNz0/GRNKRwdudp1cblNqORgg8wz+ImcfDLpwmdklPpdVdiE5O8O10mGEbRmT4CzBQtgJuATRRS5rz0ko45EHuJtJZ5+qwj3lUaN4iiRkTGILRklYCodIxBA6dDHSu6lqmyRFClTtu7nLE5bgRiiUYbwFRq+ZNIP/W6S17p8gfoZ5EbjhcLiMmvpslHECzoQoTJn4xSzaI1G360oXYFztc21UypvwlmRGttguedYoHeuh5NifBjGW1kQ87FhQEUKUoI6FOEG0YymUtsCcjNvaUJwHdBpiGzZ0hAuf4uzSSQgcqFJYejHLEpaigEhIPEcbtULMzW3EgrZcqI+POtZhzznueoPh0bB7OHikBVrIdz9S3usYyVCflPp5TOQuqzolkuJiaQe9njbx19m93diLhTdlLxbSlH2haqGNkiCGo1VIKP15ct9LDkachJYjV3VwPbzHLsR0FYmjE6gPKeQrTkJQmkSjgBORPoaKIur1W3nJb7CzG5w5mVqoYvFm9dTwSxaiizws2aYpy1DYLw+eQoO+ljgSiY3DQpuaivVULXc9tBMShhTfY2xLFE+nUpAQPyNRXJ65KjX/z7TbgPYEj3XIINdMSpyAQm4hdY4WzWnZm9ZY1guW+dfzhr1PyCRlXKKkcM4cKyeOfEaNqDaWdl+2sgj/58ZcTRkv6boyX9K7NfTKOWDAYsJhwmCyX5buQ1e9yjKxVhJ7zU68jcDUuaxga3DObEjU+bpga3AiwZMgmWmB5lSdtZyq82tOLSGo7mZvt+aqTEm44jCDNSXiimPNb2sbRgMuhINFB0vRdIAUTQdF0XqVpjkH5Pv+xrllQmVyWEk3oTM5q6Tv5CroG7SAFE0HRtF0QBRt6SqVWh5MANzi5WW9KmArLki5vmpucswfdgHmBPzCAH/FYU5AxWFOQMWx54JWm6xJepiWU9JN6WFaSknfcyFb8nzjUNu9JYUmBguYzkDjvZyqcCZhotLqD0IctS0RIIphonTUgT9tMVrqyTq9/HlUXlA8IhLBEVzn8bpNWfLUeb5uc5Y8O23QVQbWF9s6oFWu+pzfGaxUT1HGdjufExwtB1rqHLy/ZndM2TyAyYq0YcC6fM7ikd/K7QLnhd133Xa7muuGQVY+U9nuynqa9Wnu3m0Q1txtAFofFIp8TLeDUFHSUz6TIkXFKHFl2qcoOKvYDRiFKJs4NMh84Is4mybhdhAcns0djmHECk/oIibpE7WUz9n5JqasQ21iEWbM8AQNGnS5LyUnMDLGwPJ4hj9YfOZ3b9DI7+u6nobh3piz+Nkw1JUwGdOlU+Yq2LmsGAma7HxMNqkfJkz7plYBFHgmF1u3uG4McZkNILquCxaGrnvkeq7rdV2v73rD93+8+OfV9zcvX9/89fP1u5+s7IeU4rN1+8vbu6vf3l/9eXf1O0zib3794ebb19fvXt5990J9ffMqJ92+/fv6zdfw9fbHb5Z3rJY3dIaHE9F+8C9UCu/e"}),e[1]||(e[1]=a("<p>这个图表展示了React如何在一帧内分配时间：</p><ol><li>浏览器工作（0-5ms）：这是浏览器处理事件、样式计算、布局等任务的时间。</li><li>React工作（5-10ms）：这是React执行更新、渲染组件的时间。React会尝试在这个时间段内完成尽可能多的工作。</li><li>空闲时间（10-15ms）：如果React完成了所有高优先级的工作，它会利用这段时间来处理低优先级的任务。</li><li>安全余量（15-16.67ms）：React保留一小段时间作为缓冲，以防止意外的延迟导致帧超时。</li></ol><p>React如何知道还有多少时间可用：</p><ol><li>性能监控：React使用<code>performance.now()</code>来精确测量时间。</li><li>动态调整：React会记录每次工作的持续时间，并使用这些数据来预测未来的工作时间。</li><li>提前退出：如果React发现剩余时间不足，它会停止当前工作并让出控制权给浏览器。</li><li>优先级队列：React维护一个任务优先级队列，确保在有限的时间内执行最重要的任务。</li></ol><p>通过这种机制，React能够智能地利用每一帧中的可用时间，在保持应用响应性的同时，逐步完成所有必要的更新工作。这就是React能够实现流畅用户界面的关键所在。</p><p>需要注意的是，这是一个简化的解释。实际的React调度器实现更为复杂，包括了更多的优化和边缘情况处理。</p>",6))])}const n=c(r,[["render",p],["__file","核心理念.html.vue"]]);export{n as default};
