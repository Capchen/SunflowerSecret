import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as u,c as s,a as l,b as e,d as r,e as o}from"./app-a7d0c61b.js";const b={},d={href:"https://www.webpackjs.com/plugins/define-plugin",target:"_blank",rel:"noopener noreferrer"},a={href:"https://segmentfault.com/a/1190000015938570",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/chrisvfritz/prerender-spa-plugin",target:"_blank",rel:"noopener noreferrer"};function k(g,n){const p=t("ExternalLinkIcon");return u(),s("div",null,[n[16]||(n[16]=l("<p><strong>1、压缩输出</strong><br> 我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。<br> 从 webpack 4 开始，也可以通过 &quot;mode&quot; 配置选项轻松切换到压缩输出，只需设置为 &quot;production&quot;。</p><p><strong>是因为使用了mode为生产模式，webpack会自动应用优化插件</strong></p><p>webpack.optimize.UglifyJsPlugin<br> 上面的压缩混淆插件在webpack版本小于3.0时，使用的是v0.4.6版本<br> 在webpack4中计划使用1.0.0版本，最新的使用按照官网上的步骤来，下载安装uglifyjs-webpack-plugin</p><p><strong>2、生产环境的配置</strong><br> 使用 webpack-merge 可以合并两个配置文件</p>",4)),e("p",null,[n[1]||(n[1]=e("strong",null,"3、指定环境",-1)),n[2]||(n[2]=e("br",null,null,-1)),n[3]||(n[3]=r(" 其实，当使用 p")),n[4]||(n[4]=e("wbr",null,null,-1)),n[5]||(n[5]=r("rocess.env.NODE_ENV === 'production' 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。")),n[6]||(n[6]=e("br",null,null,-1)),n[7]||(n[7]=r(" 我们可以使用 webpack 内置的 ")),e("a",d,[n[0]||(n[0]=r("DefinePlugin")),o(p)]),n[8]||(n[8]=r(" 为所有的依赖定义这个变量"))]),n[17]||(n[17]=l(`<p>概念：webpack是个资源打包器，能处理文件之间的依赖关系，并且生成一个文件，主要有以下四个概念<br> 1.入口<br> 2.出口<br> 3.loader<br> 4.插件</p><p>优化第一点：<br> 1。作用域提升，webpack打包的时候会把每一个模块放到一个单独的闭包里面，如果有很多模块，闭包相对应的就多<br> 所以，使用作用域提升可以减少闭包的数量。所以在webpack3.0中有ModuleConcatenationPlugin这个插件，来提升作用域，<br> 但是需要注意的一点是只对es module语法生效，即import/export default</p><p>2.CommonsChunkPlugin 优化的思路就是通过将公共模块拆出来，最终合成的文件能在最开始的是加载一次，便于后续访问其余页面，直接使用浏览器缓存中的公共代码，这样无疑体验会更好。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>new webpack.optimize.CommonsChunkPlugin({ // 这里的意思是将node_module中的模块抽离出来，成为vendor name: &#39;vendor&#39;, minChunks: function (module, count) { // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &#39;../node_modules&#39;) ) === 0 ) }, chunks:[&#39;app&#39;] }), // // extract webpack runtime and module manifest to its own file in order to // // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin({ // 这里是从vendor里面把runtime 这部分代码抽离出来，名字是manifest name: &#39;manifest&#39;, chunks: [&#39;vendor&#39;] // 这个属性的意思是通过 chunk name 去选择 chunks 的来源。chunk 必须是 公共chunk 的子模块，指定source chunk，即指定从哪些chunk当中去找公共模块，省略该选项的时候，默认就是entry chunks // minChunks: Infinity // 这种写法和上面的写法效果一样，会马上生成公共chunk，但里面没有模块 }),


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样改变业务代码，就不用部署vendor代码。但是如果业务代码增加删除依赖还是会导致vendor变化，因为依赖的id变化了。</p><p>先来说一下各种教程以及文档中CommonsChunkPlugin提及到chunk有哪几种，主要有以下三种：</p><ol><li>webpack当中配置的入口文件（entry）是chunk，可以理解为entry chunk</li><li>入口文件以及它的依赖文件通过code split（代码分割）出来的也是chunk，可以理解为children chunk</li><li>通过CommonsChunkPlugin创建出来的文件也是chunk，可以理解为commons chunk</li></ol>`,7)),e("p",null,[n[10]||(n[10]=r("在webpack4 legato 中已经被移除，新的分包工具使用 ")),e("a",a,[n[9]||(n[9]=r("SplitChunksPlugin")),o(p)])]),n[18]||(n[18]=e("p",null,"从4.0版本开始CommonsChunkPlugin被移除且被optimization.splitChunks和optimization.runtimeChunk配置项代替.下面展示它们将如何工作.",-1)),n[19]||(n[19]=e("p",null,"webpack4以上无法使用  extract-text-webpack-plugin，用 mini-css-extract-plugin 代替",-1)),n[20]||(n[20]=e("p",null,[r("3。对于前两种方式 ，第三种是使用DllPlugin 和 DllReferencePlugin ，配合pwa，"),e("br"),r(" dll插件则是预先打好一些三方库， 生成的dll文件和json文件，然后在build构建的时候根据json的映射去dll文件里面找到依赖的库，"),e("br"),r(" 也减小体积")],-1)),n[21]||(n[21]=e("p",null,"总结下现在公司PC端使用的打包优化策略",-1)),e("p",null,[n[12]||(n[12]=r("1.预渲染，")),e("a",m,[n[11]||(n[11]=r("prerender-spa-plugin")),o(p)]),n[13]||(n[13]=r("插件")),n[14]||(n[14]=e("br",null,null,-1)),n[15]||(n[15]=r(" 2.公共部分打包 CommonsChunkPlugin"))]),n[22]||(n[22]=l("<p>2019/02/26 日总结回顾<br> webpack低于4.0版本<br> 使用commonsChunkPlugin来进行分包，将node_module中的三方库打包在一起，然后再将运行文件抽离，配合htmlwebpackplugin<br> 将分好的包引入index.html<br> 减少了app.js体积</p><p>dll和commons两个插件一起使用可能会造成重复打三方库的包</p><p>webpack插件原理：<br> 在webpack构建的生命周期中，初始化时会遍历plugin选项中的插件，通过注册事件来监听，然后在生命周期中需要的时间点触发插件功能。</p><p>插件功能的实现，是通过操作 Webpack 对外暴露的事件钩子</p><p>总结流程就是：</p><ul><li>Webpack 的配置文件中所有依赖的插件通过 new XXXPlugin() 的方式填写在 plugin 配置项下，这些 Plugin 中注册了特定事件并提供了回调。</li><li>在 Webpack 初始化配置阶段将遍历 plugin 配置项并将每个 Plugin 都注册</li><li>接下来在Webpack 主流程运行时，每个关键生命周期点通过 call 方式触发特定事件，注册了特定事件的 Plugin 回调被调用，回调方法中被注入编译对象，可以获取到特定事件触发时编译对象的状态（即当前编译信息）并完成一些操作达到扩展目的。</li></ul><p>实际上不仅仅是用户配置的 Plugin，在 Webpack 源码中很多的流程操作也是基于 Plugin 的方式实现的，所以可以说 Webpack 就是一个插件合集。</p><p>Webpack 的运行过程可以简单概括为以下几个步骤：</p><p>配置解析 -&gt; 内置插件&amp;配置插件注册 -&gt; 确认入口获取依赖资源 -&gt; 使用Loader翻译资源 -&gt; 识别资源加载语句并递归的遍历所有资源 -&gt; 封装依赖资源输出结果</p><p>接下来：<br> 1.<br> vue-cli3有了基本的配置，只需要补充下一些优化操作</p><p>当开启extract<br> 为true时，是应用了css提取插件</p><p>不应用时，css会内嵌到js代码中</p><p>webpack4和3的插件，也就是<br> mini-css-extract-plugin<br> 和<br> extract-text-webpack-plugin<br> 两者的对比差异如图</p><p>主要是第一点和第二点：支持按需加载和没有重复的编译<br> 后者要配合OptimizeCSSPlugin 插件实现去除重复编译</p><p>摇树（tree-shaking）理解<br> 1.何为摇树<br> 2.如何使用</p><p>摇树是指把项目工程看成是一颗树，其中没有用到的函数或者模块啥的，是这个工程中不需要打包的东西，这时候<br> 就可以通过摇树这个动作将不必要的东西舍弃</p><p>webpack4新增了一个 sideEffects 属性，，通过给 package.json 加入 sideEffects声明该 包/模块 是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。<br> 如果你的代码确实有一些副作用，可以改为提供一个数组。</p><p><strong>注意</strong>：</p><p>1.有没有副作用是相对于本身的包或模块 有没有改变外部的值，可以理解为是否是个纯函数。<br> 这也就是因为babel转换的原因，导致代码肯定会有副作用，比如babel转换为了更符合ES6语义，转化个iife函数来封装类</p><p>以上可以知道，第二点的条件在babel之后肯定不能满足，有一个解决方案就是先摇树，然后再babel编译<br> 这对我们自己的项目可以这个做，但是处理第三方库时，别人肯定是打好包的编译的<br> 所以一些三方库也有自己的按需导入的处理</p><p>所以为什么打包库还是rollup好用<br> 1.它支持程序流分析，在解析的时候就确定了哪些有没有副作用<br> 2.它支持导出es模块的包</p>",21))])}const c=i(b,[["render",k],["__file","笔记.html.vue"]]);export{c as default};
