import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as h,c as t,a,e as n}from"./app-ac5c95d2.js";const l="/SunflowerSecret/assets/http1-2-93f69dbc.png",p="/SunflowerSecret/assets/http1-1-5dc2996d.png",o={};function c(s,e){const i=d("Mermaid");return h(),t("div",null,[e[0]||(e[0]=a('<figure><img src="'+l+'" alt="各版本对比" tabindex="0" loading="lazy"><figcaption>各版本对比</figcaption></figure><h2 id="http1" tabindex="-1"><a class="header-anchor" href="#http1" aria-hidden="true">#</a> HTTP1</h2><p>1996年出现，在这之前是HTTP0.9<br> 0.9：</p><ol><li>只有get</li><li>没有请求头</li><li>没有HTTP状态码，</li></ol><p>1.0改善了这些点：</p><ol><li>增加了POST</li><li>能编辑请求头</li><li>并且有HTTP状态码</li></ol><p>但是，1.0也有不足：</p><ol><li>每个链接都需要自己发起TCP链接</li></ol><h2 id="http1-1" tabindex="-1"><a class="header-anchor" href="#http1-1" aria-hidden="true">#</a> HTTP1.1</h2><p>1997年HTTP1.1出现了，带来了更全面的功能：</p><h3 id="keep-live" tabindex="-1"><a class="header-anchor" href="#keep-live" aria-hidden="true">#</a> keep-live</h3><p>长链接，通过TCP握手后，这个链接不会被关闭，减少了连接和关闭的时延，<br> 但是有数量限制（取决于浏览器的并发控制，一般是6个左右）。</p><p>通过请求头<code>Connection: keep-alive</code>开启</p><h3 id="pipeling" tabindex="-1"><a class="header-anchor" href="#pipeling" aria-hidden="true">#</a> pipeling</h3><p>管道，它允许在一个TCP链接上发起多个请求和接受多个响应。这里需要注意的是，在一个长链接的管道上，虽然多个请求可以用同一个链接，但请求不能同时发送。</p><p>只能一个个排队来，这就造成了队头阻塞的问题：队头消息的处理延迟会阻碍后续消息的处理</p><h4 id="队头堵塞" tabindex="-1"><a class="header-anchor" href="#队头堵塞" aria-hidden="true">#</a> 队头堵塞</h4>',17)),n(i,{id:"mermaid-83",code:"eJyFjTESgkAMRXtOkRILCqCzoNET6AkyEJnMrHFNIg63F9hOZtiU77/8b/T+kPR0ZRwVnwUsF1Gde44oDpfAJL7Dd9KJdMPJqLousTPc1kpzqLc40WrJk7jmFl9iBDWUAwWcaTgdNzVQfpGdZcyI7Z94PP5gwRBmQFWeyLIvTU5oix959mur"}),e[1]||(e[1]=a('<p>原因：</p><ol><li>HTTP/1.x 的串行性：在 HTTP/1.x 中，请求和响应是按顺序处理的。</li><li>TCP 的可靠性机制：TCP 协议的重传机制可能导致整个数据流的延迟。</li><li>网络延迟：高延迟的网络环境会加剧队头阻塞问题。</li></ol><p>解决办法：</p><ol><li>建立多个连接：浏览器通常会为每个域名打开多个并行连接（通常是 6 个）。</li><li>域名分片：将资源分布在多个域名下，以增加可用的并行连接数。</li><li>HTTP/2 多路复用：HTTP/2 允许在单个 TCP 连接上并行处理多个请求和响应。</li><li>HTTP/3 和 QUIC：使用基于 UDP 的 QUIC 协议，进一步减少了队头阻塞。</li><li>资源内联和合并：将小型资源直接嵌入 HTML 或合并多个资源，减少请求数量。</li></ol><h4 id="chunk" tabindex="-1"><a class="header-anchor" href="#chunk" aria-hidden="true">#</a> chunk</h4><p>分块传输，服务器的数据不用一次性返回所有数据。</p><h4 id="缓存控制-cache-control-etag-if-modified-since-last-modified" tabindex="-1"><a class="header-anchor" href="#缓存控制-cache-control-etag-if-modified-since-last-modified" aria-hidden="true">#</a> 缓存控制 cache-control/etag/if-modified-since/last-modified</h4><p>控制缓存策略，协商缓存/强缓存. 这里不展开</p><h2 id="http2" tabindex="-1"><a class="header-anchor" href="#http2" aria-hidden="true">#</a> HTTP2</h2><p>2015，他来了</p><p>针对HTTP1.1暴露出的一些问题，2带来新的功能</p><h3 id="二进制协议替代文本协议" tabindex="-1"><a class="header-anchor" href="#二进制协议替代文本协议" aria-hidden="true">#</a> 二进制协议替代文本协议</h3><p>HTTP2使用的是二进制协议，不是文本协议，所以他可以将数据拆分成更小的二进制帧。数据量更小</p><h3 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用" aria-hidden="true">#</a> 多路复用</h3><figure><img src="'+p+'" alt="多路复用和长链接对比" tabindex="0" loading="lazy"><figcaption>多路复用和长链接对比</figcaption></figure><p>和1.*不同的是，多路复用允许在一个链接中同时发起多个请求，而无序排队等待。这是因为基于二进制帧的架构，可以通过帧的头部来标记循序，从而可以完整拼凑数据包。在一定程度上缓解队头阻塞的问题。</p><h3 id="service-push" tabindex="-1"><a class="header-anchor" href="#service-push" aria-hidden="true">#</a> service push</h3><p>主动推送</p><h3 id="头部压缩" tabindex="-1"><a class="header-anchor" href="#头部压缩" aria-hidden="true">#</a> 头部压缩</h3><p>在 HTTP/1.x 中，每个请求都会发送完整的头部信息，这导致了大量的冗余数据传输。特别是在移动网络环境下，这种冗余会显著影响性能。HTTP/2 引入了 HPACK 压缩格式来解决这个问题。</p><h2 id="http3" tabindex="-1"><a class="header-anchor" href="#http3" aria-hidden="true">#</a> HTTP3</h2><p>2022，他又来了</p><p>本质的区别，没有基于TCP协议，而是基于UDP协议去实现。</p><h3 id="无队头阻塞" tabindex="-1"><a class="header-anchor" href="#无队头阻塞" aria-hidden="true">#</a> 无队头阻塞</h3><p>协议不一样，从根本解决队头阻塞</p><h3 id="无感知的网络切换" tabindex="-1"><a class="header-anchor" href="#无感知的网络切换" aria-hidden="true">#</a> 无感知的网络切换</h3><p>移动端设备在从wifi切换为5g或者4g时，是不会断线重连</p>',27))])}const P=r(o,[["render",c],["__file","HTTP一览.html.vue"]]);export{P as default};
