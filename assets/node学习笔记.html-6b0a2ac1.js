import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,d as i}from"./app-c79e1b77.js";const r={},d=i(`<h3 id="commonjs规范" tabindex="-1"><a class="header-anchor" href="#commonjs规范" aria-hidden="true">#</a> commonJS规范</h3><h4 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h4><p>一个文件为一个模块，对模块的定义分为： 模块引用，模块定义，模块标识三个部分</p><h5 id="模块引用" tabindex="-1"><a class="header-anchor" href="#模块引用" aria-hidden="true">#</a> 模块引用</h5><p><code>const chenjian = require(./chenjian.js)</code></p><h5 id="模块定义" tabindex="-1"><a class="header-anchor" href="#模块定义" aria-hidden="true">#</a> 模块定义</h5><p>上下文提供了export对象来导出模块，在模块中还存在一个module对象，它代表模块自身，所以export是<br> module的属性。<br><code> export.say = function (){alert(&#39;hellow, i am good man&#39;)}</code></p><h5 id="模块标识" tabindex="-1"><a class="header-anchor" href="#模块标识" aria-hidden="true">#</a> 模块标识</h5><p>模块标识其实就是传递给require的参数</p><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1558345821818-aa74a9b4-861b-4087-a477-f4571de85cbd.png#align=left&amp;display=inline&amp;height=242&amp;name=image.png&amp;originHeight=242&amp;originWidth=556&amp;size=24200&amp;status=done&amp;width=556" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="node-对模块的实现" tabindex="-1"><a class="header-anchor" href="#node-对模块的实现" aria-hidden="true">#</a> node 对模块的实现</h3><p>node中模块的实现还是和commonsJS有些不同的<br> 引入一个文件，node会进行<br> 1.文件路径分析<br> 2.文件定位<br> 3.文件编译<br> node中的那些内置模块在node进程运行的时候就已经编译到内存中了，所以内置模块的获取和访问是最快的</p><p>node对模块的访问会和浏览器一样对对象进行缓存，但是浏览器缓存的对象是文件，而node则是编译和执行之后的<br> 对象</p><p>1.<strong>node对CommonJs的实现</strong>：事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。<br> 一个正常的JavaScript文件会被包装成如下的样子</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>(function (exports, require, module, __filename, __dirname) {
  var math = require(&#39;math&#39;);
  exports.area = function (radius) {
    return Math.PI * radius * radius;
  };
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。</p><p>2.Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。</p><p>3.<strong>模块类型的层级关系：</strong></p><p>内建模块（纯c/c++编写的模块） ===&gt; 核心模块（部分c/c++编写，由javascript封装的模块，Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的。） ===&gt; 文件模块（指开发者自己创建的文件）</p><h3 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> node</h3>`,20),o=[d];function t(s,c){return a(),n("div",null,o)}const l=e(r,[["render",t],["__file","node学习笔记.html.vue"]]);export{l as default};
