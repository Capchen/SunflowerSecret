import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as l,c as d,a as e,b as a,e as t,d as r}from"./app-0373d365.js";const s="/SunflowerSecret/assets/image-49378ac5.png",c={},h=r('<h2 id="什么是微前端" tabindex="-1"><a class="header-anchor" href="#什么是微前端" aria-hidden="true">#</a> 什么是微前端</h2><blockquote><p>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。</p></blockquote><h2 id="面临的主要问题" tabindex="-1"><a class="header-anchor" href="#面临的主要问题" aria-hidden="true">#</a> 面临的主要问题</h2><ol><li>如何解决css污染</li><li>如何解决js污染</li><li>如何解决应用间通信</li><li>如何保持子应用的路由状态</li></ol><h2 id="iframe方案" tabindex="-1"><a class="header-anchor" href="#iframe方案" aria-hidden="true">#</a> iframe方案</h2><p>主要是利用浏览器原生标签<code>&lt;iframe&gt;</code>提供的能力</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ol><li>浏览器原生支持，完美隔离</li><li>上手简单</li></ol><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ol><li>隔离太完美，无法保持子应用路由状态</li><li>隔离太完美，DOM结构不共享</li><li>隔离太完美，每次启动都是初始化，性能有瓶颈</li></ol><h2 id="single-spa方案" tabindex="-1"><a class="header-anchor" href="#single-spa方案" aria-hidden="true">#</a> single-spa方案</h2>',11),p={href:"https://zh-hans.single-spa.js.org/docs/getting-started-overview#%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88",target:"_blank",rel:"noopener noreferrer"},f=r('<figure><img src="'+s+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>其主要实现思路：预先注册子应用(激活路由、子应用资源、生命周期函数)，监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数并最终渲染到容器。</p><h2 id="乾坤的解决方案" tabindex="-1"><a class="header-anchor" href="#乾坤的解决方案" aria-hidden="true">#</a> 乾坤的解决方案</h2><p>乾坤是基于<code>single-spa</code>的封装，简化了一些配置操作，同时完善了隔离策略（js/css）,并且通过缓存策略加快打开速度。</p><p>但同时，也还是有一些其他的限制：</p><ul><li>基于路由匹配，无法同时激活多个子应用，也不支持子应用保活</li><li>改造成本较大，从 webpack、代码、路由等等都要做一系列的适配</li><li>css 沙箱无法绝对的隔离，js 沙箱在某些场景下执行性能下降严重</li><li>无法支持 vite 等 ESM 脚本运行</li></ul><h2 id="无界的解决方案" tabindex="-1"><a class="header-anchor" href="#无界的解决方案" aria-hidden="true">#</a> 无界的解决方案</h2>',7),m={href:"https://wujie-micro.github.io/doc/guide/",target:"_blank",rel:"noopener noreferrer"},u=r(`<p>无界还是在<code>&lt;iframe&gt;</code>上做文章，回顾上文的<a href="#iframe%E6%96%B9%E6%A1%88">iframe方案</a>的缺点，我们看看无界是如何去解决的</p><h3 id="路由同步机制-解决无法保持子应用路由状态" tabindex="-1"><a class="header-anchor" href="#路由同步机制-解决无法保持子应用路由状态" aria-hidden="true">#</a> 路由同步机制（解决无法保持子应用路由状态）</h3><blockquote><p>劫持iframe的history.pushState和history.replaceState，就可以将子应用的url同步到主应用的query参数上，当刷新浏览器初始化iframe时，读回子应用的url并使用iframe的history.replaceState进行同步</p></blockquote><h3 id="iframe-连接机制-解决dom结构不共享" tabindex="-1"><a class="header-anchor" href="#iframe-连接机制-解决dom结构不共享" aria-hidden="true">#</a> iframe 连接机制(解决DOM结构不共享)</h3><ul><li><p>关键点一： <code>webcomponent</code></p><pre><code>子应用的实例instance在iframe内运行，dom在主应用容器下的webcomponent内
</code></pre></li><li><p>关键点二： 代理</p><pre><code>将document的查询类接口：getElementsByTagName、getElementsByClassName、getElementsByName、getElementById、querySelector、querySelectorAll、head、body全部代理到webcomponent，这样instance和webcomponent就精准的链接起来。
</code></pre></li></ul><h3 id="应用加载机制-解决每次启动都是初始化-性能有瓶颈" tabindex="-1"><a class="header-anchor" href="#应用加载机制-解决每次启动都是初始化-性能有瓶颈" aria-hidden="true">#</a> 应用加载机制（解决每次启动都是初始化，性能有瓶颈）</h3><blockquote><p>将子应用的js注入主应用同域的iframe中运行，iframe是一个原生的window沙箱，内部有完整的history和location接口，子应用实例instance运行在iframe中，路由也彻底和主应用解耦，可以直接在业务组件里面启动应用。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>想要落地微前端，无非就是解决上文中的<a href="#%E9%9D%A2%E4%B8%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98">主要问题</a>,<br> 乾坤和无界都有很好的实践方案去解决。</p><p>至于选择哪个框架还是需要基于当前面临的业务场景和历史包袱去做权衡。</p>`,10);function _(b,g){const i=n("ExternalLinkIcon");return l(),d("div",null,[h,e("p",null,[a("详情点击"),e("a",p,[a("官网"),t(i)])]),f,e("p",null,[a("详情点击"),e("a",m,[a("官网"),t(i)])]),u])}const B=o(c,[["render",_],["__file","乾坤与无界.html.vue"]]);export{B as default};
