import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as d,c as o,a as e,b as a,e as i,d as c}from"./app-87a845fd.js";const h={},p=e("h3",{id:"什么是微前端",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#什么是微前端","aria-hidden":"true"},"#"),a(" 什么是微前端")],-1),s={href:"https://hackernoon.com/understanding-micro-frontends-b1c11585a297",target:"_blank",rel:"noopener noreferrer"},m={href:"http://micro-frontends.org",target:"_blank",rel:"noopener noreferrer"},l=c('<p>也可以简单的理解为：微前端是一种利用工具拆分来达到工程拆分治理的方案。可以解决工程膨胀/开发维护困难等问题。</p><p>映射到我们的BF：产品模块现在已经有9，10个，产品模块里面有可能还包含更复杂的业务，所以需要拆分，现在我们也是这么做的。</p><h3 id="微前端需要解决的问题" tabindex="-1"><a class="header-anchor" href="#微前端需要解决的问题" aria-hidden="true">#</a> 微前端需要解决的问题</h3><h4 id="多个独立的子业务如何统一ui体验-css和公共组件" tabindex="-1"><a class="header-anchor" href="#多个独立的子业务如何统一ui体验-css和公共组件" aria-hidden="true">#</a> 多个独立的子业务如何统一UI体验（CSS和公共组件）</h4><h4 id="微应用之间如何共享全局信息-登陆信息-证书过期信息" tabindex="-1"><a class="header-anchor" href="#微应用之间如何共享全局信息-登陆信息-证书过期信息" aria-hidden="true">#</a> 微应用之间如何共享全局信息（登陆信息，证书过期信息）</h4><h4 id="微应用中的路由如何管理-解析加载对应微应用资源" tabindex="-1"><a class="header-anchor" href="#微应用中的路由如何管理-解析加载对应微应用资源" aria-hidden="true">#</a> 微应用中的路由如何管理（解析加载对应微应用资源）</h4><h3 id="bf是如何处理这些问题的" tabindex="-1"><a class="header-anchor" href="#bf是如何处理这些问题的" aria-hidden="true">#</a> BF是如何处理这些问题的</h3><p>BF中产品和业务的拆分，肯定绕不过上面三个问题。我们可以看BF是如何处理，并思考哪些可以改进。<br> 先来一张前端工程架构概述图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1594179896964-fd4bdb2d-5eeb-4b2e-aa96-6cfa7885b90d.png#align=left&amp;display=inline&amp;height=414&amp;name=image.png&amp;originHeight=413&amp;originWidth=658&amp;size=39803&amp;status=done&amp;style=none&amp;width=659" alt="image.png" loading="lazy"></p><h4 id="第一个问题" tabindex="-1"><a class="header-anchor" href="#第一个问题" aria-hidden="true">#</a> 第一个问题：</h4><p>统一UI，BF使用 <code>elementUI</code> 来作为一些基本组件的开发。但是重新设计了自己的UI风格。并且封装了一些公共组件，包括：素材库，panel等。这些公共组件和css都是在common-module里面。common-module作为一个应用独立部署。可以看上图。<br> 我们在微应用中的使用的方式就是这样<br><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1594180804660-892e4b4a-667a-4ca7-bc5d-8118b50ae021.png#align=left&amp;display=inline&amp;height=133&amp;name=image.png&amp;originHeight=266&amp;originWidth=1312&amp;size=63916&amp;status=done&amp;style=none&amp;width=656" alt="image.png" loading="lazy"><br> 和<br><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1594180872247-37cca75f-9f2b-4027-9d5e-d9364fdb651e.png#align=left&amp;display=inline&amp;height=478&amp;name=image.png&amp;originHeight=956&amp;originWidth=1042&amp;size=170326&amp;status=done&amp;style=none&amp;width=521" alt="image.png" loading="lazy"></p><h4 id="第二个问题" tabindex="-1"><a class="header-anchor" href="#第二个问题" aria-hidden="true">#</a> 第二个问题：</h4><p>微应用之间没有通讯机制，一些用户信息，授权信息，都是通过一进来就调用接口获取。存储方面就是在localstorage中进行数据的交换同步</p><h4 id="第三个问题" tabindex="-1"><a class="header-anchor" href="#第三个问题" aria-hidden="true">#</a> 第三个问题：</h4><p>产品模块的入口，都是在bf页面的左边。通过在表中插入信息，在点击事件的时候跳转到不同的应用。跳转的代理，就轮到上图的load-balance上场了。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1594204409981-f4e979fa-8005-4d16-b9d4-4429ce13d9a9.png#align=left&amp;display=inline&amp;height=243&amp;name=image.png&amp;originHeight=486&amp;originWidth=1070&amp;size=71500&amp;status=done&amp;style=none&amp;width=535" alt="image.png" loading="lazy"><br> load-balance里面就是一个nginx，专门用来做各种代理转发。可以看到上图就是对ccbot.html这个路径转发到ccbot/#/，而/ccbot又转发到了定义好的ip+端口的服务上，也就是启动的docker上（docker集群中每个docker容器都会暴露出ip+端口）<br> 进入到微应用之后，就是通过docker容器内的nginx去处理接口的转发和代理了。</p>',14);function g(b,f){const n=t("ExternalLinkIcon");return d(),o("div",null,[p,e("p",null,[a("引用"),e("a",s,[a("https://hackernoon.com/understanding-micro-frontends-b1c11585a297"),i(n)]),a("这篇文章的定义")]),e("blockquote",null,[e("p",null,[a("Micro Frontends背后的想法是将网站或Web应用视为独立团队拥有的功能组合。每个团队都有一个独特的业务或任务领域，做他们关注和专注的事情。团队是跨职能的，从数据库到用户界面开发端到端的功能。（"),e("a",m,[a("micro-frontends.org"),i(n)]),a("）")])]),l])}const k=r(h,[["render",g],["__file","从微前端看BF开发模式.html.vue"]]);export{k as default};
