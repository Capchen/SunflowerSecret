import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as r,c as d,a,b as e,e as o,d as p}from"./app-01797cae.js";const c={},h=p('<blockquote><p>希望能够使用 React 语法写小程序的同时，通过「<strong>Write once Run anywhere</strong>」来实现跨端的。</p></blockquote><h5 id="《小程序跨框架开发的探索与实践》演讲全文" tabindex="-1"><a class="header-anchor" href="#《小程序跨框架开发的探索与实践》演讲全文" aria-hidden="true">#</a> <a href="">《小程序跨框架开发的探索与实践》演讲全文</a></h5><h3 id="选型参考" tabindex="-1"><a class="header-anchor" href="#选型参考" aria-hidden="true">#</a> 选型参考</h3><h4 id="一、" tabindex="-1"><a class="header-anchor" href="#一、" aria-hidden="true">#</a> 一、</h4><blockquote><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1658458212376-b49929b8-a365-470c-9fa1-0acd1ed4cc25.png#clientId=u96ba7115-3cc6-4&amp;from=paste&amp;height=451&amp;id=ud0ab9d1a&amp;name=image.png&amp;originHeight=444&amp;originWidth=676&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82176&amp;status=done&amp;style=none&amp;taskId=u92fe5621-509a-4378-a80e-93634f9a3ed&amp;title=&amp;width=687" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></blockquote><h4 id="二、" tabindex="-1"><a class="header-anchor" href="#二、" aria-hidden="true">#</a> 二、</h4><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1658458298552-b9a62512-3add-48d3-b8ce-977e0a13b8ce.png#clientId=u96ba7115-3cc6-4&amp;from=paste&amp;height=543&amp;id=u3fa7bf97&amp;name=image.png&amp;originHeight=602&amp;originWidth=758&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=261352&amp;status=done&amp;style=none&amp;taskId=u65aaf04a-a0b7-41ef-97a0-261314bcd29&amp;title=&amp;width=684" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h3><h4 id="_3之前的" tabindex="-1"><a class="header-anchor" href="#_3之前的" aria-hidden="true">#</a> 3之前的：</h4><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1653530590832-13699126-4892-4797-abcb-d1739b0b407e.png#clientId=u69f0cedc-3d9c-4&amp;from=paste&amp;height=259&amp;id=u5da2f416&amp;name=image.png&amp;originHeight=448&amp;originWidth=796&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=95817&amp;status=done&amp;style=none&amp;taskId=u19591826-32d3-4f6c-bd0c-fc1eb0286e6&amp;title=&amp;width=461" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="_3之后的" tabindex="-1"><a class="header-anchor" href="#_3之后的" aria-hidden="true">#</a> 3之后的</h4><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1658452800658-988fa750-2f13-4a19-855d-ce5c51b4cc75.png#clientId=u96ba7115-3cc6-4&amp;from=paste&amp;height=159&amp;id=udb40ae85&amp;name=image.png&amp;originHeight=422&amp;originWidth=1234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=165055&amp;status=done&amp;style=none&amp;taskId=u9678a04f-a053-4463-97f4-581ad1a7e73&amp;title=&amp;width=465" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h5 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别：</h5><p>重编译和重运行时，而重运行时带来的好处是，模拟DOM/BOM API：</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1653536397477-589a3fed-bdab-47af-87ee-48d025fe255e.png#clientId=u69f0cedc-3d9c-4&amp;from=paste&amp;height=247&amp;id=u87ed2785&amp;name=image.png&amp;originHeight=494&amp;originWidth=1370&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=159837&amp;status=done&amp;style=none&amp;taskId=uc60dad64-64b8-42cc-b01b-3454106d5d0&amp;title=&amp;width=685" alt="image.png" loading="lazy"></h3><h3 id="mpvue" tabindex="-1"><a class="header-anchor" href="#mpvue" aria-hidden="true">#</a> mpvue</h3><p>mpvue 本质上还是将 Vue 运行在了小程序，在platform目录下实现了小程序的转化。</p><h3 id="vue支持" tabindex="-1"><a class="header-anchor" href="#vue支持" aria-hidden="true">#</a> Vue支持</h3><ul><li>从<code>v3.0.0</code>版本（01 Jul 2020）支持的vue3开发</li></ul><h3 id="taro小程序" tabindex="-1"><a class="header-anchor" href="#taro小程序" aria-hidden="true">#</a> Taro小程序</h3><ol><li>先基于cli为react/vue代码用webpack打包</li><li>运行时使用适配器进行适配，调用Taro实现的DOM/BOM API，</li><li>渲染到小程序页面</li></ol><h3 id="taro-dom-tree-如何更新到页面" tabindex="-1"><a class="header-anchor" href="#taro-dom-tree-如何更新到页面" aria-hidden="true">#</a> Taro DOM Tree 如何更新到页面</h3><h4 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h4><ol><li>先将小程序的组件模版化</li><li>将Taro Runtime 生成的Taro Dom Tree，去匹配模版</li><li>匹配遍历完Taro Tree之后，得到的就是小程序的组件Tree</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/297368/1658458821752-0bb51c59-5d61-4998-8f2a-929d74689e44.png#clientId=u96ba7115-3cc6-4&amp;from=paste&amp;height=274&amp;id=uabb70561&amp;name=image.png&amp;originHeight=359&amp;originWidth=696&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=270486&amp;status=done&amp;style=none&amp;taskId=u6e7485aa-b053-46f7-a46c-7c7856e76f7&amp;title=&amp;width=531" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h4><p>Vue 和 React 最大的区别就在于运行时的 CreateVuePage 方法，这个方法里进行了一些运行时的处理，比如：生命周期的对齐。其他的部分，如通过 BOM/DOM 方法构建、修改 DOM Tree 及渲染原理，都是和 React 一致的。</p><h4 id="更新" tabindex="-1"><a class="header-anchor" href="#更新" aria-hidden="true">#</a> 更新</h4>',28),m=a("br",null,null,-1),l={href:"http://root.cn",target:"_blank",rel:"noopener noreferrer"},s=a("br",null,null,-1),g=a("img",{src:"https://cdn.nlark.com/yuque/0/2022/png/297368/1658458460741-8cb7c7e9-ab7d-4a35-910b-9a1700c76c5d.png#clientId=u96ba7115-3cc6-4&from=paste&height=265&id=uf0ed8f51&name=image.png&originHeight=364&originWidth=729&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149898&status=done&style=none&taskId=u53490226-1b24-4e6e-81da-89f2b7f420d&title=&width=531.5",alt:"image.png",loading:"lazy"},null,-1),u=a("h3",{id:"taro-npm",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#taro-npm","aria-hidden":"true"},"#"),e(" Taro NPM")],-1),f=a("figure",null,[a("img",{src:"https://cdn.nlark.com/yuque/0/2022/png/297368/1658458624594-3d7e4506-ec75-42d5-ad13-790cceb6eeea.png#clientId=u96ba7115-3cc6-4&from=paste&height=929&id=uabf7fb73&name=image.png&originHeight=929&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=165954&status=done&style=none&taskId=u2ede6cc5-e263-48ac-bb1d-620a507cee5&title=&width=637",alt:"image.png",tabindex:"0",loading:"lazy"}),a("figcaption",null,"image.png")],-1);function b(y,T){const i=n("ExternalLinkIcon");return r(),d("div",null,[h,a("p",null,[e("无论是 React 还是 Vue ，最终都会调用 Taro DOM 方法，如：appendChild、insertChild 等。"),m,e(" 这些方法在修改 Taro DOM Tree 的同时，还会调用 enqueueUpdate 方法，这个方法能获取到每一个 DOM 方法最终修改的节点路径和值，如：{"),a("a",l,[e("root.cn"),o(i)]),e('.[0].cn.[4].value: "1"}，并通过 setData 方法更新到视图层。'),s,g]),u,f])}const k=t(c,[["render",b],["__file","Taro.html.vue"]]);export{k as default};
