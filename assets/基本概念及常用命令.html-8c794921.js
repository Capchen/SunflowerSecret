import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,d as s}from"./app-87a845fd.js";const r={},c=s(`<h3 id="镜像image" tabindex="-1"><a class="header-anchor" href="#镜像image" aria-hidden="true">#</a> 镜像image</h3><p>分层存储</p><h3 id="容器container" tabindex="-1"><a class="header-anchor" href="#容器container" aria-hidden="true">#</a> 容器container</h3><p>基于镜像的最上层再加一层，作为容器的存储层。他和镜像的关系类似与<strong>类</strong>和<strong>实例</strong></p><h3 id="仓库" tabindex="-1"><a class="header-anchor" href="#仓库" aria-hidden="true">#</a> 仓库</h3><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> web2 <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">81</span>:80 nginx:v2 //基于nginx:v2镜像启动名为web2的容器并映射本机81端口到容器的80端口
<span class="token function">docker</span> image <span class="token function">ls</span> // 列出镜像
<span class="token function">docker</span> image <span class="token function">ls</span> <span class="token parameter variable">-a</span> // 列出中间层镜像
<span class="token function">docker</span> container <span class="token function">ls</span> // 列出容器
<span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span> // 删除没有使用的镜像
<span class="token function">docker</span> <span class="token function">ps</span> ｜grep <span class="token variable"><span class="token variable">$(</span>name<span class="token variable">)</span></span> // 筛选过滤
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="compose" tabindex="-1"><a class="header-anchor" href="#compose" aria-hidden="true">#</a> compose</h3><p>它允许用户通过一个docker-compose.yml模板文件来定义一组相关联的容器为一个项目</p><h4 id="compose中的两个重要概念" tabindex="-1"><a class="header-anchor" href="#compose中的两个重要概念" aria-hidden="true">#</a> compose中的两个重要概念</h4><h5 id="服务-service-一个应用的容器-实际上可以包括若干运行相同镜像的" tabindex="-1"><a class="header-anchor" href="#服务-service-一个应用的容器-实际上可以包括若干运行相同镜像的" aria-hidden="true">#</a> 服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的</h5><h5 id="项目-project-由一组关联的应用容器组成的一个完整业务单元-在docker-compose-yml文件中定义" tabindex="-1"><a class="header-anchor" href="#项目-project-由一组关联的应用容器组成的一个完整业务单元-在docker-compose-yml文件中定义" aria-hidden="true">#</a> 项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</h5><h3 id="挂载操作" tabindex="-1"><a class="header-anchor" href="#挂载操作" aria-hidden="true">#</a> 挂载操作</h3><p>挂载是指两者中做出的修改都会影响另一方<br> \`\`pwd<code>:/usr/share/nginx/html:ro -v</code><br> 上面的意思是将本地的目录和容器内部的html文件关联挂载，只读<br><code></code>pwd<code>&quot;/deploy/dev/nginx.conf&quot;:/etc/nginx/conf.d/default.conf</code><br>  上面的意思是将本地目录下的nginx.cong和容器内部的default.conf挂载关联</p><h3 id="进入对应容器" tabindex="-1"><a class="header-anchor" href="#进入对应容器" aria-hidden="true">#</a> 进入对应容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token variable"><span class="token variable">$(</span>容器id<span class="token variable">)</span></span> <span class="token function">sh</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,16),i=[c];function o(d,t){return e(),n("div",null,i)}const h=a(r,[["render",o],["__file","基本概念及常用命令.html.vue"]]);export{h as default};
