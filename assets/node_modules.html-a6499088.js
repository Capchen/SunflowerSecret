import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as s,c as p,a as e,b as a,e as o,d}from"./app-f0a1e793.js";const t={},c={href:"https://zhuanlan.zhihu.com/p/137535779",target:"_blank",rel:"noopener noreferrer"},l=d('<h3 id="package" tabindex="-1"><a class="header-anchor" href="#package" aria-hidden="true">#</a> package</h3><p>包含了package.json，使用package.json定义的一个package。通常是对应一个module，也可以不包含module。</p><h3 id="module" tabindex="-1"><a class="header-anchor" href="#module" aria-hidden="true">#</a> module</h3><p>能被require的，就是一个module，只有当module里面包含package.json的时候，它才叫package。</p><h3 id="dependency-hell" tabindex="-1"><a class="header-anchor" href="#dependency-hell" aria-hidden="true">#</a> Dependency Hell</h3><p>依赖地狱。<br> 当A，C都依赖B，A依赖的是B的1.0.0版本。C依赖的是B的2.0.0版本。在B版本能支持多版本共存的情况下，npm如何解决保证让A，C都加载到自己想要的版本？<br> npm的解决方式是通过加载依赖时路径的查找算法和node_modules的目录结构这两者来配合解决的</p><h4 id="查找算法" tabindex="-1"><a class="header-anchor" href="#查找算法" aria-hidden="true">#</a> 查找算法</h4><p>递归向上查找node_modules里面的package</p><blockquote><p>eg.<br> 如果在 <code>&#39;/home/ry/projects/foo.js&#39;</code> 文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p><ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul></blockquote><p>-- 递归向上<br> -- 就近原则</p><h4 id="node-modules的目录结构" tabindex="-1"><a class="header-anchor" href="#node-modules的目录结构" aria-hidden="true">#</a> node_modules的目录结构</h4><figure><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1589538479785-9b9033a3-d0b6-40bb-95d7-bf9cdcbf86c5.png#height=310&amp;id=z1aGJ&amp;name=image.png&amp;originHeight=982&amp;originWidth=460&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66172&amp;status=done&amp;style=none&amp;title=&amp;width=145" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="nest-mode-npm-v2" tabindex="-1"><a class="header-anchor" href="#nest-mode-npm-v2" aria-hidden="true">#</a> nest mode(npm v2)</h3><p>根据上面dependency hell的解决方案，我们可以想到如果acorn-jsx和acorn-dynamic-import同时依赖一个package的不同版本，只要在他们自己的目录下维护就好了。因为是就近原则。但是如果此时有另外一个模块，也依赖这个同acorn-jsx相同版本的package，那么就会导致同时存在两个相同版本的package。<br> 如果依赖的过多，会导致大量空间被浪费。这就是臭名昭著的node_modules hell</p><h3 id="flat-mode-npm-v3" tabindex="-1"><a class="header-anchor" href="#flat-mode-npm-v3" aria-hidden="true">#</a> flat mode（npm v3）</h3><p>同样，这个模式，是利用向上递归查找的原则，解决nest mode的重复依赖问题。它把重复的依赖提取为公共依赖，放到上一层的node_modules。<br> 但是，如果有四个模块，其中两个依赖了1.0.0版本，另外两个依赖了2.0.0版本，那么不论是把1.0.0放到上一层还是把2.0.0放到上一层，都会造成某个版本依赖两次。这时你可能会想：为啥不把1.0.0和2.0.0都放到上一层，这不就只要install一次吗。如果都放到上一层，我怎么保证我拿到的是1.0.0版本还是2.0.0版本？ 这叫做doppelgangers</p><h3 id="版本重复问题" tabindex="-1"><a class="header-anchor" href="#版本重复问题" aria-hidden="true">#</a> 版本重复问题</h3><p>版本重复及同时存在多个版本，会出现什么问题？</p><h4 id="全局types冲突" tabindex="-1"><a class="header-anchor" href="#全局types冲突" aria-hidden="true">#</a> 全局types冲突</h4><p>一些package会修改全局的类型定义，全局的types形成了命名冲突。解决方式就是自己控制包含哪些加载的</p><h4 id="破坏单例模式" tabindex="-1"><a class="header-anchor" href="#破坏单例模式" aria-hidden="true">#</a> 破坏单例模式</h4><h3 id="phantom-dependecy" tabindex="-1"><a class="header-anchor" href="#phantom-dependecy" aria-hidden="true">#</a> Phantom dependecy</h3><p>对比以上flat mode会比nest mode节省很多空间，同时也带来了phantom dependecy的问题。什么是phantom dependecy？<br> 我们把一个库使用了不属于其dependencies里的package称之为phantom dependecy。我理解：A，C模块依赖1.0.0，现在把1.0.0提升一层，那么在AC的dependencies里面肯定没有1.0.0<br> 另外，在同一个库里面，有可能引用的依赖不在dependencies里面而是在devDependencies里面，我们本地开发运行没有问题，但是发布的话别人下载安装依赖就会有问题了。<br> 并且在使用monorepo管理项目的情况下，问题更加严重。一个package不但可能引入dev环境下的phantom dependecy，也有可能引入其他package的依赖。<br><strong>在基于npm或者yarn的node_modules的结构下，doppelganger 和 phantom dependency这两个问题似乎并没有太好的解决方式。</strong></p><h3 id="semver-语意化版本" tabindex="-1"><a class="header-anchor" href="#semver-语意化版本" aria-hidden="true">#</a> Semver(语意化版本)</h3><p>semver的提出主要用于控制每个依赖package的影响范围，能实现系统的平滑升级和过度。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/297368/1589783983490-06c804e9-d48f-485c-a09f-45500df54c76.png#height=80&amp;id=PFxRL&amp;name=image.png&amp;originHeight=80&amp;originWidth=388&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7724&amp;status=done&amp;style=none&amp;title=&amp;width=388" alt="image.png" loading="lazy"><br> 前面加个^表示npm install 的时候都会安装符合0.18.0约束的最新依赖。<br> 问题是。并不是所有的库都会遵循。所以。。。<br> 如果直接写死axios的版本依赖，但是不能保证axios的依赖也是写死。所以，packge-lock.json和yarn的lock文件就是实现这样的方式。<br> 如上图的package.json里面声明的axios依赖，我们在生成的package-lock.json文件中可以看到。axios所有的依赖及其依赖的依赖的版本都在lock文件中锁定了。这样其他人来使用这个package就能复现版本。<br><strong>但是当我们第一次安装创建项目时或者第一次安装某个依赖的时候，此时即使第三方库里含有lock文件。但是npm install 并不会去读取三方依赖的lock，所以还是有可能触发bug。</strong></p>',25),h=e("h3",{id:"resolutions-救火队长",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#resolutions-救火队长","aria-hidden":"true"},"#"),a(" Resolutions 救火队长")],-1),m={href:"https://classic.yarnpkg.com/en/docs/selective-version-resolutions/",target:"_blank",rel:"noopener noreferrer"},u=e("br",null,null,-1),g=e("code",null,"npm-froce-resolution",-1),b=d('<h3 id="determinism" tabindex="-1"><a class="header-anchor" href="#determinism" aria-hidden="true">#</a> determinism</h3><p>determinism指的是在给定package.json和lock文件下，每次重新install都会得到同样的node_modules的拓扑结构。</p><h3 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> PNPM</h3><p>相比于yarn尽可能的将package放到root level，pnpm则是只将显式写明的dependency的依赖写入root-level的node_modules，这避免了业务里错误的引入隐式依赖的问题，即解决了phantom dependency</p><p>pnpm不仅仅能保证一个项目里的所有package的每个版本是唯一的，甚至能保证你使得你不同的项目之间也可以公用唯一的版本（只需要公用store即可），这样可以极大的节省了磁盘空间。核心就在于pnpm不再依赖于node的递归向上查找node_modules的算法，因为该算法强依赖于node_modules的物理拓扑结构，这也是导致不同项目的项目难以复用node_modules的根源。（还有一种干法，就是使用代码的地方写死依赖的版本号，这是deno的干法）</p><h3 id="cargo-全局store的包管理系统" tabindex="-1"><a class="header-anchor" href="#cargo-全局store的包管理系统" aria-hidden="true">#</a> cargo（全局store的包管理系统）</h3><h2 id="cjm-esm" tabindex="-1"><a class="header-anchor" href="#cjm-esm" aria-hidden="true">#</a> CJM/ESM</h2><ol><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJs 是单个值导出，ES6 Module可以导出多个</li><li>CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层</li><li>CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</li></ol>',8);function f(_,k){const n=i("ExternalLinkIcon");return s(),p("div",null,[e("p",null,[a("原文链接"),e("a",c,[a("https://zhuanlan.zhihu.com/p/137535779"),o(n)])]),l,e("blockquote",null,[h,e("p",null,[a("如果你某天安装了一个新的webpack-cli，却发现这个webpack-cli并不能正常工作，经过一番定位发现，是该cli的一个上游依赖portfinder的最近一个版本有bug，但是该cli的作者在休假，没办法及时修复这个cli，但项目赶着上线该怎么处理？yarn提供了一个叫做"),e("a",m,[a("https://classic.yarnpkg.com/en/docs/selective-version-resolutions/"),o(n)]),a("的机制，使得你可以忽略dependency的限制，强行将portfinder锁定为某个没有bug的版本，以解燃眉之急"),u,a(" npm本身没有提供resolution机制，但是可以通过"),g,a("这个库实现类似机制")])]),b])}const v=r(t,[["render",f],["__file","node_modules.html.vue"]]);export{v as default};
