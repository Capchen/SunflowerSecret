import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c,a as t,b as a,d as s,e as l}from"./app-595d18e5.js";const u={},r={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage",target:"_blank",rel:"noopener noreferrer"};function d(m,n){const p=i("ExternalLinkIcon");return o(),c("div",null,[n[7]||(n[7]=t('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>这个算法主要是定义&quot;对象有没有被其他对象引用&quot;为依据，来决定是否回收。<br> 但是如果两个对象之前互相引用，那么就会回收不了</p><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>这个算法是定义&quot;对象能否被获得&quot;为依据，能否被获得指的是从根元素，也可以理解为全局，去获得被引用的元素，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>现在所有浏览器的垃圾回收机制都是基于标记清除的算法来实现优化。</p><h3 id="event-loop" tabindex="-1"><a class="header-anchor" href="#event-loop" aria-hidden="true">#</a> Event Loop</h3><p>JavaScript 的并发模型基于“事件循环”</p><p>首先要有队列queue，栈stack，堆heap的概念</p><figure><img src="https://cdn.nlark.com/yuque/0/2019/svg/297368/1558924186766-88436107-7963-4a90-8ea8-a01f3cf988b1.svg#align=left&amp;display=inline&amp;height=270&amp;originHeight=270&amp;originWidth=294&amp;status=done&amp;width=294" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10)),a("blockquote",null,[a("p",null,[n[1]||(n[1]=s("一个 web worker 或者一个跨域的 ")),n[2]||(n[2]=a("code",null,"iframe",-1)),n[3]||(n[3]=s(" 都有自己的栈，堆和消息队列。两个不同的运行时只能通过 ")),a("a",r,[n[0]||(n[0]=a("code",null,"postMessage",-1)),l(p)]),n[4]||(n[4]=s(" 方法进行通信。如果另一运行时侦听 ")),n[5]||(n[5]=a("code",null,"message",-1)),n[6]||(n[6]=s(" 事件，则此方法会向其添加消息。"))])]),n[8]||(n[8]=t(`<p>事件循环就是会不断判断队列中是否有可执行的事件，来运行。<br> 有了这个概念之后，开始思考，运行一段js代码的时候，事件循环机制是如何工作的。<br> 众所周知，js是单线程作业，这里在浏览器环境中要明白浏览器是多进程的，js脚本执行是浏览器渲染进程中的一个线程。和它同为线程的还有GUI渲染线程，定时器触发线程等</p><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1558946584182-57e7ce52-1c84-4d42-b722-42063d59dc8a.png#align=left&amp;display=inline&amp;height=125&amp;name=image.png&amp;originHeight=125&amp;originWidth=644&amp;size=14418&amp;status=done&amp;width=644" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1558947011843-960e8536-6e22-4300-88fc-9c6218d24033.png#align=left&amp;display=inline&amp;height=447&amp;name=image.png&amp;originHeight=447&amp;originWidth=221&amp;size=43107&amp;status=done&amp;width=221" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>分析下面这段代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数声明两个函数，函数声明提升。bar函数返回了foo函数<br> 最后一行执行bar方法</p><p>函数调用形成一个栈帧</p><p>此时的消息队列中，是没有任何事件的，因为js引擎并没有异步操作或者注册了什么事件（即没有向消息队列中添加消息）。只有上面的同步任务<br> 所以此时的执行栈里面是bar函数，bar函数上面又压了个foo函数，当foo函数运行结束之后，这个函数（参数和局部变量：指向堆的一系列指针）就会被抛出栈，然后等bar运行完毕，同样也会被抛出栈，当栈为空时，意味着同步任务的一个函数执行完了，事件循环机制就去拉取消息队列中的第一个任务执行。</p><p>现在有下面这段代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;setTimeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script end&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先说执行结果</p><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1558949568434-7c66239b-a30b-482a-8eb1-3f3f14ef2d7d.png#align=left&amp;display=inline&amp;height=124&amp;name=image.png&amp;originHeight=124&amp;originWidth=157&amp;size=3526&amp;status=done&amp;width=157" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>这涉及到宏任务（macrotask）和微任务（microtask）</p><p>setTimeout 众所周知是定时器，上面代码的意思是立即插入一个匿名回调函数，<br> promise 众所周知是异步处理函数，后面接了两个异步回调</p><p>回到我们的队列，栈，堆中来</p><p>js执行，此时我们第一个遇到的是同步代码（ script start）,然后遇到setTimeout，<br> 什么时候将setTimeout的回调推入消息队列呢？计时器线程会计时，等倒计时结束，<strong>事件触发线程</strong>就会负责推入，这里为0，表示以最快的速度推入，就是代码运行到这里就推入了。但是推入之后不一定立马执行，因为此时我们的执行栈不为空，<br> 然后继续执行同步任务。遇到promise，也会向消息队列中添加任务。但是和setTimeout不同的是，promise添加的是微任务，所以会有两个队列来进行分工，macrotask在一个队列中，microtask在另一个队列中。</p><p>所有会有下面的<br><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1558950918438-3cfbb34f-5b61-4f8f-8672-1d2f9e9187ec.png#align=left&amp;display=inline&amp;height=515&amp;name=image.png&amp;originHeight=515&amp;originWidth=728&amp;size=20185&amp;status=done&amp;width=728" alt="image.png" loading="lazy"></p><p>那么这两个队列的执行顺序是怎样的？<br> 当执行栈（starck）为空时就会将microtask里面的任务都执行，那么相信结果就很明显了<br> 执行完 start 和end ，这时strack里面是空的，那么就执行第一个promise回调，执行完第一个promise回调，遇到了第二个promise回调，那就会将第二个执行回调放到microtask里面，执行完之后，栈为空，那就再去运行微任务队列，输出promise2，这时microtask里面是没有任务了，那将由macrotask接手接下来的操作，执行setTimeout<br> 的回调，输出setTimeout</p><p>那么哪些是macrotask，哪些是microtask呢</p><h4 id="macrotask" tabindex="-1"><a class="header-anchor" href="#macrotask" aria-hidden="true">#</a> macrotask</h4><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1559006520108-f7d173c5-0684-4689-bfe5-f214fdd7f97e.png#align=left&amp;display=inline&amp;height=179&amp;name=image.png&amp;originHeight=179&amp;originWidth=384&amp;size=7532&amp;status=done&amp;width=384" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="microtask" tabindex="-1"><a class="header-anchor" href="#microtask" aria-hidden="true">#</a> microtask</h4><figure><img src="https://cdn.nlark.com/yuque/0/2019/png/297368/1559006540001-43a2cf9a-3a9a-42be-8c1c-06dca67e1286.png#align=left&amp;display=inline&amp;height=194&amp;name=image.png&amp;originHeight=194&amp;originWidth=779&amp;size=21387&amp;status=done&amp;width=779" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>`,23))])}const f=e(u,[["render",d],["__file","内存，事件循化机制.html.vue"]]);export{f as default};
