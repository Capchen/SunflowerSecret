const e=JSON.parse('{"key":"v-5ed7954e","path":"/%E9%9D%A2%E8%AF%95/%E5%B7%A6%E6%89%8B%E7%B2%98%E7%9D%80Vue%E5%8F%B3%E6%89%8B%E8%88%9E%E7%9D%80React.html","title":"左手粘着Vue右手舞着React","lang":"zh-CN","frontmatter":{"article":true,"author":{"name":"Cap"},"category":"","date":"2024-10-21T00:00:00.000Z","description":"作为前端开发工程师，当我们左手拿着 Vue，右手拿着 React，关于它们的种种，其实我们都应该是了然于胸的。 宏观概念 拿到一个前端框架，我们更应该如何去看？肯定不是一头扎进 api 的调用方式，也不是一头扎进源码的海洋。我们应该有对比的看，和你熟悉的一个框架去对比。 众所周知，前端接触最多的是浏览器，浏览器也是面向用户最直接的宿主环境。我们的页面，不管是 SPA,SSR 在浏览器呈现出来的，就是 html/css/js。所以我们以结果触发，首先看，这个框架是如何生成 html/css/js 的？ 我们先掌握这个宏观概念，再带着疑问去看细节。","editLink":false,"icon":"","image":"","isOriginal":true,"shortTitle":"Vue与React","star":true,"sticky":106,"tag":"","timeline":true,"title":"左手粘着Vue右手舞着React","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/SunflowerSecret/%E9%9D%A2%E8%AF%95/%E5%B7%A6%E6%89%8B%E7%B2%98%E7%9D%80Vue%E5%8F%B3%E6%89%8B%E8%88%9E%E7%9D%80React.html"}],["meta",{"property":"og:site_name","content":"Cap"}],["meta",{"property":"og:title","content":"左手粘着Vue右手舞着React"}],["meta",{"property":"og:description","content":"作为前端开发工程师，当我们左手拿着 Vue，右手拿着 React，关于它们的种种，其实我们都应该是了然于胸的。 宏观概念 拿到一个前端框架，我们更应该如何去看？肯定不是一头扎进 api 的调用方式，也不是一头扎进源码的海洋。我们应该有对比的看，和你熟悉的一个框架去对比。 众所周知，前端接触最多的是浏览器，浏览器也是面向用户最直接的宿主环境。我们的页面，不管是 SPA,SSR 在浏览器呈现出来的，就是 html/css/js。所以我们以结果触发，首先看，这个框架是如何生成 html/css/js 的？ 我们先掌握这个宏观概念，再带着疑问去看细节。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Cap"}],["meta",{"property":"article:published_time","content":"2024-10-21T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"左手粘着Vue右手舞着React\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-21T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cap\\"}]}"]]},"headers":[{"level":2,"title":"宏观概念","slug":"宏观概念","link":"#宏观概念","children":[]},{"level":2,"title":"组件化","slug":"组件化","link":"#组件化","children":[{"level":3,"title":"React 选择的是函数组件","slug":"react-选择的是函数组件","link":"#react-选择的是函数组件","children":[]},{"level":3,"title":"Vue 选择了 SFC（虽然它也支持 JSX）","slug":"vue-选择了-sfc-虽然它也支持-jsx","link":"#vue-选择了-sfc-虽然它也支持-jsx","children":[]}]},{"level":2,"title":"数据驱动","slug":"数据驱动","link":"#数据驱动","children":[]},{"level":2,"title":"vue 的 value","slug":"vue-的-value","link":"#vue-的-value","children":[]},{"level":2,"title":"React 的 Class 组件和函数组件","slug":"react-的-class-组件和函数组件","link":"#react-的-class-组件和函数组件","children":[]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[]}],"readingTime":{"minutes":5.08,"words":1523},"filePathRelative":"面试/左手粘着Vue右手舞着React.md","localizedDate":"2024年10月21日","excerpt":"<p>作为前端开发工程师，当我们左手拿着 Vue，右手拿着 React，关于它们的种种，其实我们都应该是了然于胸的。</p>\\n<h2> 宏观概念</h2>\\n<p>拿到一个前端框架，我们更应该如何去看？肯定不是一头扎进 api 的调用方式，也不是一头扎进源码的海洋。我们应该有对比的看，和你熟悉的一个框架去对比。</p>\\n<p>众所周知，前端接触最多的是浏览器，浏览器也是面向用户最直接的宿主环境。我们的页面，不管是 SPA,SSR<br>\\n在浏览器呈现出来的，就是 html/css/js。所以我们以结果触发，首先看，这个框架是如何生成 html/css/js 的？<br>\\n我们先掌握这个宏观概念，再带着疑问去看细节。</p>","autoDesc":true}');export{e as data};
